Jackrabbit/Hippo repository consistency checker.

Performs a consistency check based on a the default repository as
specified by the repository.xml file.  You probably need to specify a
different repository.xml configuration file that you use to go to your
database.  This configuration file can be specified using the standard
repo.config system property and can be specified using:

  -Drepo.config=/full/path/to/repository.xml file.

A sample repository.xml file is produced using the "sample" option,
see below.  At the command line usage as described below, the
checker-app.jar should be replaced by the full jar name, usally
something like hippo-repository-checker-app-2.21.05-SNAPSHOT-uber.jar

USE WITH CARE, ALWAYS BACKUP YOUR PERSISTENT STORAGE AND VERIFY THE
RESULT.


Command line usage:

  java -Drepo.config=... -jar checker-app.jar

    Performs a parent-child and references consistency check on the
    persistent storage and tries to repair any inconsistencies used.

  java -jar checker-app.jar -h | --help | help

    Displays this usage message.

  java -jar checker-app.jar sample hostname database username password

    Outputs a sample repository.xml file based on JDBC connections
    to a MySQL database running at the indicated hostname storing
    the repository below the indicated database and using the
    given username/password credentials.

  java -Drepo.config=... -jar checker-app.jar <mode> <arguments...>

The different modes the consistency checker application can run in:

  java -jar checker-app.jar true

    Runs a large scale parent-child and references consistency check
    and repais automatically as much issues as it finds.  This does not
    check any search indices, nor if nodes are self-consistent.

  java -jar checker-app.jar false

    Runs a large scale parent-child and references consistency without
    repairing any found inconsistency will report on them in the logging.

  java -jar checker-app.jar fixMixinSetFromProp <uuid-1> <uuid-2>..

    This mode repairs the corruption from a corruptMixinSetClear by
    resetting the node definition to the same value as indicated by the
    jcr:mixinTypes.

    If no UUIDs are given, all nodes are checked and reported on, but
    no changes are made.  With one or multiple UUIDs only the given nodes
    are checked and repaired.  By specifying "all" instead of any UUID,
    all nodes are checked and repaired.

  java -jar checker-app.jar fixMixinSet <uuid> <mixin-1> <mixin-2>...

    This mode repairs the corruption from a corruptMixinSetClear
    by resetting the node definition to a given set of mixin types.
    Only a single node can be repaired by specifying at first the uuid
    followed by the mixin names.

  java -jar checker-app.jar unlistChildren <uuid-1> <uuid-2>..

    Use a brute force approach to repairing nodes with corrupt mixin
    node definition of mixin property by removing them from the parent.
    A consistency fix must be run afterwards to delete the orphaned node
    from the storage and indices.  The uuid you need to specify is
    the PARENT of the actual broken node.  Afterwards, this parent
    no longer references the broken node.
    As with previous modes, zero or more uuids can be given.

  java -jar checker-app.jar fixChildrenOfMixinSetFromProp <uuid-1>..

    Works like the fixMixinSetFromProp mode, but instead of indicating
    the uuid of the node that is being fixed, the uuid of it's parent
    is specified.  All direct children of this parent node will have
    their node definition fixed.  If is often necessary to use this
    option instead of fixMixinSetFromProp because you are unable to
    retrieve the uuid of the broken node itself.
    As with previous modes, zero or more uuids can be given.

  java -jar checker-app.jar fixChildrenOfMixinSetTo <uuid> <mixin-1> <mixin-2>

    Works like the fixMixinSet mode, but instead you indicate the
    parent of the node that needs fixing and all direct children are
    repaired.

   java -jar checker-app.jar dump <uuid-1> <uuid-2>

    Dumps parent/child relationship of the indicated node(s) to standard
    output.

Development modes to deliberately BREAK a repository storage are:

  java -jar checker-app.jar corruptMixinPropClear <uuid-1> <uuid-2>..

    Corrupts the persistent storage by deliberately setting the
    jcr:mixinTypes property to zero elements, but leaving the node
    definition in place.
    As with previous modes, zero or more uuids can be given.

  java -jar checker-app.jar corruptMixinPropDrop <uuid-1> <uuid-2>..

    Corrupts the persistent storage by deliberately removing the
    jcr:mixinTypes property, but leaving the node definition in place.
    This is not a real corruption as the repository will fall-back to
    using the original node definition for the property.
    As with previous modes, zero or more uuids can be given.

  java -jar corruptMixinSetClear <uuid-1> <uuid-2>

    Corrupts the persistent storage by deliberately setting the node
    definition to contain no mixin types, but leaving the jcr:mixinTypes
    property in place.  This is the encountered corruption where there
    are still jcr:uuid properties, etc. but the node is not referenceable.
    As with previous modes, zero or more uuids can be given.

