<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE document PUBLIC
  "-//Apache Software Foundation//DTD XDOC 1.0//EN"
  "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<!--
  Copyright 2008 Hippo

  Licensed under the Apache License, Version 2.0 (the  "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS"
  BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<document>
    <properties>
        <title>Core developer information</title>
    </properties>
    <body>

<section name="Setting up and using Selenium tests">

<p>
Integration tests are designed to check the functionality of the application
as a whole, rather than the internal working of an individual section of
program code, which is the domain of normal unit testing.
</p>

<p>
Selenium is such a toolset to create and run integration tests.
</p>

<p>
Requirements:
</p>
<ul>
<li>Hippo ECM, maven, and usual tools to build Hippo ECM</li>
<li>Firefox 3;</li>
<li>Selenium IDE 1.0b2 add-on plugin for Firefox;</li>
<li>Wicket 1.3.5 (which will be patched).</li>
</ul>
<p>
to run the automated tests furthermore:
</p>
<ul>
<li>Application container supporting standard JSR-88 (programmatic interface
to deploy applications), such as glassfish (recommended), Websphere, WebLogic,
etcetera.  Tomcat and Jetty as not EE application containers.</li>
</ul>

<p>
This description will assume you have basic knowledge on how to build Hippo
ECM and how to operate application containers in general.  It will describe in
generic terms how to run the applications, when using different programs than
described or on different installations the directory paths, and commands used
will vary.
</p>

<p>
The current trunk of Hippo ECM already contains the proper infrastructure for
Selenium-based integration testing. This description will first outline how to 
run this integration test.  Having done that, it outlines how to compose tests.  
First of all, we start by setting up the required environment.
</p>

<p>
Next subsections describe:
</p>
<ul>
<li>Patch and compile wicket 1.3.5, compile Hippo ECM;</li>
<li>Setup application server;</li>
<li>Run provided simple Selenium test;</li>
</ul>

<subsection name="Building wicket and Hippo ECM for running integration tests">

<p>
check out a recent copy of Hippo ECM:
</p>
<source>
  svn checkout 'http://svn.onehippo.org/repos/hippo/hippo-ecm/trunk' hippo-ecm
</source>
<p>
and the wicket 1.3.5 release:
</p>
<source>
  svn checkout 'http://svn.apache.org/repos/asf/wicket/releases/wicket-1.3.5' wicket-1.3.5
</source>
<p>
now apply the patch to allow the generation of stable markup ids:
</p>
<source>
  cd wicket-1.3.5
  patch -p0 &lt; ../hippo-ecm/tools/testutils/wicket-selenium.patch
</source>
<p>
compile the modified sources and install them in your local maven repository
</p>
<source>
  mvn -DskipTests install
</source>
<p>
this version will now be used in the compilation of hippo-ecm:
</p>
<source>
  cd ../hippo-ecm
  mvn -DskipTests install
</source>
<p>
Make sure that in the future the modified wicket installation is not overwritten
or re-downloaded.  The patched wicket 1.3.5 installation is FULLY compatible
with the original 1.3.5 release.
</p>

<blockquote>
  Background information:

  The patched wicket 1.3.5 is necessary to run and develop Selenium based
  tests.  Wicket normally generates markup ids on the fly for wicket
  components.  These markup ids can vary from request to request making 
  them unsuitable for identifying a component in the browser DOM.

  Since Selenium uses the markup ids to identify,  for example,  which element
  was clicked,  tests might fail because the Selenium test had no proper way 
  of identifying the items being indicated.

  Generation of stable markup ids, that when the same run is done the ids are
  the same as the ids from a previous run, is in certain situations possible.
  However when wicket generates the ids, this method does not have the right
  information upon which the stable id can be generated.

  A request for integration on this patch will be submitted to the wicket
  developers.
</blockquote>

<p>
Note that the patch is not required to run the CMS.  Because of the way the
patch has been constructed and the CMS code works, the generation of stable
ids is only active with the patched version.
</p>

</subsection>
<subsection name="Get your application server">

<p>
Make sure you have a proper application server, such as Glasfish which can
be obtained freely from:
</p>
  https://glassfish.dev.java.net/public/downloadsindex.html
<p>
Glassfish is usually installed in a directure path such as /usr/local/glassfish-v2ur2
this path is needed later as well as refered to as the installation directory of the application container.
</p>

<p>
Glassfish is started using:
</p>
<source>
  /usr/local/glassfish-v2ur2/bin/asadmin start-domain domain1
</source>
<p>
and can be stopped using
</p>
<source>
  /usr/local/glassfish-v2ur2/bin/asadmin stop-domain domain1
</source>
<p>
The administration console is usually available at
</p>
<source>
  http://localhost:4848/
</source>
<p>
with default username <code>admin</code> and password <code>adminadmin</code>.
</p>

<p>
By default Glassfish will run applications on port 8080, which often conflicts 
with other applications. Thus we have setup the tests in such a manner that the 
applications should run on port 4849.  You need to change the settings in the 
application container accordingly.  Within glassfish this can be done using the 
administration console as such:
</p>

<p>
In the left tree pane choose:
</p>

<source>
  configuration -> HTTP Service -> HTTP Listeners
</source>

<p>
In the right pane you will see the ports being listened to for http requests.
Leave the admin-listener which normally has the Listener port set to 4848
alone.  One of the other listeners is probably set to 8080.  If none of them
are, find out which of them does not have the security setting enabled.  Click
on that one to view and edit the details.  Modify the Listener port and set it
to 4849.  Select save.
</p>

<p>
These steps complete the setup of the application server Glassfish.  As
mentioned earlier, any compliant application server is possible which should
implement the JSR-88 standard.  However the libraries needed are probably
different.  Therefor in that case you need to modify
the <code>package/pom.xml</code> and put the right libraries into
the <code>additionalClasspathElement</code> entries in the maven surefire
plugin configuration.  In addition to this you need to modify the the class
name in the source file
<code>tools/testutils/src/main/java/org/hippoecm/testutils/deployer/Deployer.java</code>,
which is currently set to the glassfish instance of the deployment
api: <code>com.sun.enterprise.deployapi.SunDeploymentFactory</code>.
</p>

</subsection>
<subsection name="Running a simple Selenium test">

<p>
You are now ready to run the first simple Selenium test.  Under default build,
the integration tests using Selenium are <em>not</em> executed.  However by
setting the <code>appserver.home</code> system property during build, their
profile is activated.
</p>

<p>
The <code>appserver.home</code> property should be set to the location where
your application server was installed, for
instance <code>/usr/local/glassfish-v2ur2</code>.  This parameter is passed
maven using the -D flag.
</p>

<p>
As a prerequisite to the running Selenium tests, the Seleniumn libraries
require that the firefox-bin executable is found on the system executable
path. This may or may not be the case on your system. 
</p>
<p>
For Ubuntu 8.04 (and higher) in combination with Firefox 3 this requires 
some extra setup (or at least with current Selenium version in use) as Selenium
expects the firefox binary to be called firefox-bin, which is not the case on 
Ubuntu 8.04. Thus we create a symlink in /usr/lib/firefox to the Firefox binary 
as follows: (version might differ)</p>
<source>
sudo ln -s /usr/lib/firefox-3.0.6/firefox /usr/lib/firefox/firefox-bin
</source>

<p>
Within most Unix-like system you can find the firefox binary with 
</p>
<source>
which firefox-bin
</source>
<p>
If not found, you can put the firefox-bin in your path using (bourne shell syntax):
</p>
<source>
PATH=/usr/lib/firefox-2.0.0.14:$PATH
export PATH
</source>

<p>
The path <code>/usr/lib/firefox-2.0.0.14</code> will propably differ though.
</p>

Now run the provided Selenium test using:
<source>
cd package/test
mvn -B -Dappserver.home=/usr/local/glassfish-v2ur2 integration-test
</source>

</subsection>
<subsection name="Recording a Selenium test">

<p>
Make sure you download and install the Selenium IDE plugin for Firefox.
Now deploy the EAR installation (it must be an ear installation of
the package/ear project) into the application server.  You can use
the console of the application server (for glassfish, available at
<code>http://localhost:4848/</code>).
</p>

<p>
Run firefox, and access the cms by entering the
URL <code>http://localhost:4849/</code>.  Now fire up the Selenium IDE which
is activated in the menu Tools -> Selenium IDE.  As soom as the Selenium IDE
starts, is will start recording.  As format (menu Options -> Format) you must
choose either HTML if you want to play back the recording in the Selenium IDE,
but then you cannot put this integration test into the automated Selenium
integration test for the CMS.  Or you choose JAVA to get a human readable
source representation.
</p>

<p>
Made sure that in the Base URL box the URL http://localhost:4849/ is shown.
Reload the page and this will be the first step recorded.  You can now record
a number of steps and when done you press to stop record button shown as a red
ball on the right side of the Selenium IDE window.  You can save a java-format
based test using File -> Save Test Case As.
</p>

<p>
To integrate the saved test, you can subclass the BasicSeleniumTest.java which 
does the setup/teardown of the Selenium tests and provides some helper functions
for working with Ajax-requests.  Make sure you leave the outer definitions intact,
especially the @Before and @After definition.  Just put the generated code
without the class definition in the @Test marked method.
</p>

<p>
You can also subclass CmsSeleniumTest.java which extends BasicSeleniumTest itself 
and adds functions for loading the homepage and logging in and out.
</p>

<p>
The test class you have created must now be entered into the framework.  To do 
this, modify the file:
</p>

<source>
package/test/src/test/java/org/hippoecm/repository/test/IntegrationTest.java
</source>
<p>
and add the classname to the <code>Suite.SuiteClasses</code> annotation. Don't 
forget the comma seperator and the <code>.class</code> extension.
</p>

<p>
Some notes on recording Selenium tests:
</p>
<ul>
<li>Never use the autocompletion, as this will not be properly recorded.</li>
<li>You probably need to modify the generated source.  In general the sleep
times are not the best method of testing but
<code>Selenium.isTextPresent</code> is more suited.  Look for the other tests for examples.</li>
</ul>

</subsection>
</section>

    </body>
</document>
