<?xml version="1.0" encoding="UTF-8" ?>
<!--
  Copyright 2013-2014 Hippo B.V. (http://www.onehippo.com)

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  -->
<scxml version="1.0"
       xmlns="http://www.w3.org/2005/07/scxml"
       xmlns:hippo="http://www.onehippo.org/cms7/repository/scxml"
       xmlns:cs="http://commons.apache.org/scxml"
       initial="handle">

  <script>
    def getScxmlId() { dm.scxmlId }
    def getSupports() { dm.supportedFeatures }
    def getDraft() { dm.getDocumentVariantByState('draft') }
    def getUnpublished() { dm.getDocumentVariantByState('unpublished') }
    def getPublished() { dm.getDocumentVariantByState('published') }
    def getUser() { dm.user }
    def getRequests() { dm.requests }
    def getCopySource() { published ?: unpublished ?: null }
    def getDeleteSource() { unpublished ?: published ?: draft }
    def getHolder() { draft?.holder }
    def boolean isEditable() { !draft?.holder or draft?.holder == user }
    def boolean isEditing() { !!draft?.holder }
    def boolean isEditor() { draft?.holder == user }
    def boolean isLive() { published?.isAvailable('live') }
    def boolean isPreview() { unpublished?.isAvailable('preview') }
    def boolean isModified() { unpublished and (!live or unpublished.lastModified!=published.lastModified) }
    def boolean isRequestPending() { dm.requestPending }
    def boolean isRequestActionAllowed(request, action) { !!dm.info['requests']?."$request?.identity"?."$action" }
  </script>

  <parallel id="handle">

    <state id="status">
      <onentry>
        <if cond="supports.document">
          <hippo:info info="status" value="editable"/>
          <hippo:info info="isLive" value="live"/>
          <hippo:action action="checkModified" enabledExpr="draft and unpublished"/>
        </if>
      </onentry>

      <transition event="checkModified">
        <hippo:isModified/>
        <hippo:result value="dm.info['modified']"/>
      </transition>
    </state>

    <state id="edit" initial="no-edit">

      <state id="no-edit">
        <transition target="init-edit" cond="(supports.document or supports.unlock)"/>
      </state>

      <state id="init-edit">
        <onentry>
          <if cond="supports.document">
            <hippo:action action="disposeEditableInstance" enabledExpr="false"/>
            <hippo:action action="obtainEditableInstance" enabledExpr="false"/>
            <hippo:action action="commitEditableInstance" enabledExpr="false"/>
          </if>
          <if cond="supports.unlock">
            <hippo:action action="unlock" enabledExpr="false"/>
          </if>
        </onentry>
        <transition target="not-editable" cond="requestPending"/>
        <transition target="editing"      cond="editing"/>
        <transition target="editable"/>
      </state>

      <state id="not-editable"/>

      <state id="editing">
        <onentry>
          <if cond="supports.document">
            <if cond="editor">
              <hippo:action action="disposeEditableInstance" enabledExpr="true"/>
              <hippo:action action="obtainEditableInstance" enabledExpr="true"/>
              <hippo:action action="commitEditableInstance" enabledExpr="true"/>
            <else/>
              <hippo:info info="inUseBy" value="holder"/>
            </if>
          </if>
          <if cond="supports.unlock">
            <if cond="editor or dm.isGranted(draft,'hippo:admin')">
              <hippo:action action="unlock" enabledExpr="true"/>
            </if>
          </if>
        </onentry>
      </state>

      <state id="editable">
        <onentry>
          <if cond="supports.document">
            <hippo:action action="obtainEditableInstance" enabledExpr="true"/>
          </if>
        </onentry>
      </state>

      <transition event="disposeEditableInstance" target="reset">
        <hippo:setHolder holder="null"/>
        <hippo:result value="preview ? unpublished : published"/>
      </transition>

      <transition event="obtainEditableInstance" target="reset">
        <if cond="!!unpublished">
          <hippo:copyVariant sourceState="unpublished" targetState="draft"/>
        <elseif cond="!!published"/>
          <hippo:copyVariant sourceState="published" targetState="draft"/>
        </if>
        <hippo:configVariant variant="draft" applyModified="true" setHolder="true" availabilities=""/>
        <hippo:result value="draft"/>
      </transition>

      <transition event="commitEditableInstance" target="reset">
        <hippo:setHolder holder="null"/>
        <if cond="!!unpublished">
          <hippo:isModified/>
        </if>
        <if cond="!unpublished or dm.info['modified']">
          <if cond="!unpublished and !!published">
            <if cond="live">
              <hippo:configVariant variant="published" availabilities="live"/>
            <else/>
              <hippo:configVariant variant="published" availabilities=""/>
            </if>
          </if>
          <hippo:copyVariant sourceState="draft" targetState="unpublished"/>
          <hippo:configVariant variant="unpublished" versionable="true" applyModified="true" availabilities="preview"/>
        </if>
        <hippo:result value="unpublished"/>
      </transition>

      <transition event="unlock" target="reset">
        <hippo:setHolder holder="user"/>
      </transition>

    </state>

    <state id="request" initial="no-request">

      <state id="no-request">
        <transition target="init-request" cond="supports.request"/>
      </state>

      <state id="init-request">
        <transition target="requested" cond="!empty(requests)"/>

        <transition target="not-requested"/>
      </state>

      <state id="requested">
        <onentry>
          <hippo:requestsActionsInfo/>
        </onentry>

        <transition event="acceptRequest" target="reset">

          <cs:var name="request" expr="requests[_eventdata]"/>

          <hippo:workflowException cond="isRequestActionAllowed(request,'acceptRequest')"
            errorExpr="'Cannot invoke workflow '+scxmlId+' action acceptRequest: action not allowed or request not found'"/>

          <cs:var name="requestType" expr="request.type"/>

          <if cond="requestType=='delete'">
            <hippo:workflowException cond="live"
              errorExpr="'Cannot delete document when still published'"/>

            <hippo:workflowException cond="editing"
              errorExpr="'Cannot delete document which is being edited'"/>

            <hippo:deleteRequest requestExpr="request"/>
            <hippo:invokeDocumentWorkflow action="delete"/>

          <elseif cond="requestType ==~ '(publish|scheduledpublish)'"/>

            <hippo:workflowException cond="editing"
              errorExpr="'Cannot publish document which is being edited'"/>

            <hippo:workflowException cond="!modified"
              errorExpr="'Cannot publish document when no changes present'"/>

            <if cond="requestType=='publish'">
              <hippo:deleteRequest requestExpr="request"/>
              <hippo:invokeDocumentWorkflow action="publish"/>
            <else/>
              <cs:var name="requestDate" expr="request.scheduledDate"/>
              <hippo:deleteRequest requestExpr="request"/>
              <hippo:invokeDocumentWorkflow action="scheduledpublish" whenExpr="requestDate"/>
            </if>

          <elseif cond="request.type ==~ '(depublish|scheduleddepublish)'"/>

            <hippo:workflowException cond="editing"
              errorExpr="'Cannot depublish document which is being edited'"/>

            <hippo:workflowException cond="!live"
              errorExpr="'Cannot depublish document when not published'"/>

            <if cond="requestType=='depublish'">
              <hippo:invokeDocumentWorkflow action="publish"/>
            <else/>
              <cs:var name="requestDate" expr="request.scheduledDate"/>
              <hippo:deleteRequest requestExpr="request"/>
              <hippo:invokeDocumentWorkflow action="scheduleddepublish" whenExpr="requestDate"/>
            </if>

          <else/>

            <hippo:workflowException
              errorExpr="'Unsupported request type '+(request.type)+' for workflow action acceptRequest"/>

          </if>
        </transition>

        <transition event="rejectRequest" target="reset">

          <cs:var name="request" expr="requests[(_eventdata?.requestIdentifier)]"/>
          <cs:var name="reason" expr="requests[(_eventdata?.reason)]"/>

          <hippo:workflowException cond="isRequestActionAllowed(request,'rejectRequest')"
            errorExpr="'Cannot invoke workflow '+scxmlId+' action rejectRequest: action not allowed or request not found'"/>

          <hippo:rejectRequest requestExpr="request" reasonExpr="reason"/>
        </transition>

        <transition event="cancelRequest" target="reset">
          <cs:var name="request" expr="requests[_eventdata]"/>

          <hippo:workflowException cond="isRequestActionAllowed(request,'cancelRequest')"
            errorExpr="'Cannot invoke workflow '+scxmlId+' action cancelRequest: action not allowed or request not found'"/>

          <hippo:deleteRequest requestExpr="request"/>
        </transition>
      </state>

      <state id="not-requested"/>

    </state>

    <state id="publish" initial="no-publish">

      <state id="no-publish">
        <transition target="init-publish" cond="supports.document"/>
      </state>

      <state id="init-publish">

        <onentry>
          <hippo:action action="publish" enabledExpr="false"/>
        </onentry>

        <transition target="publishable" cond="!editing and modified"/>
        <transition target="not-publishable"/>

      </state>

      <state id="not-publishable"/>

      <state id="publishable">
        <onentry>
          <if cond="!requestPending or user=='system'">
            <hippo:action action="requestPublication" enabledExpr="true"/>
            <if cond="dm.isGranted(unpublished, 'hippo:editor')">
              <hippo:action action="publish" enabledExpr="true"/>
            </if>
          </if>
        </onentry>

        <transition event="requestPublication" target="reset">
          <hippo:workflowRequest type="publish" contextVariantExpr="unpublished" targetDateExpr="_eventdata"/>
        </transition>

        <transition event="publish" cond="!_eventdata" target="reset">
          <hippo:copyVariant sourceState="unpublished" targetState="published"/>
          <hippo:configVariant variant="published" applyPublished="true" availabilities="live"/>
          <hippo:version variant="unpublished"/>
        </transition>

        <transition event="publish" cond="!!_eventdata" target="reset">
          <hippo:invokeDocumentWorkflow action="scheduledpublish" whenExpr="_eventdata"/>
        </transition>

      </state>

    </state>

    <state id="depublish" initial="no-depublish">

      <state id="no-depublish">
        <transition target="init-depublish" cond="supports.document"/>
      </state>

      <state id="init-depublish">
        <onentry>
          <hippo:action action="depublish" enabledExpr="false"/>
        </onentry>

        <transition target="depublishable" cond="!editing and live"/>
        <transition target="not-depublishable"/>

      </state>

      <state id="not-depublishable"/>

      <state id="depublishable">
        <onentry>
          <if cond="!requestPending or user=='system'">
            <hippo:action action="requestDepublication" enabledExpr="true"/>
            <if cond="dm.isGranted(published, 'hippo:editor')">
              <hippo:action action="depublish" enabledExpr="true"/>
            </if>
          </if>
        </onentry>

        <transition event="requestDepublication" target="reset">
          <hippo:workflowRequest type="depublish" contextVariantExpr="published" targetDateExpr="_eventdata"/>
        </transition>

        <transition event="depublish" cond="!_eventdata" target="reset">
          <if cond="!unpublished">
            <hippo:copyVariant sourceState="published" targetState="unpublished"/>
          </if>
          <hippo:configVariant variant="unpublished" versionable="true" availabilities="preview"/>
          <hippo:configVariant variant="published" availabilities=""/>
          <hippo:version variant="unpublished"/>
        </transition>

        <transition event="depublish" cond="!!_eventdata" target="reset">
          <hippo:invokeDocumentWorkflow action="scheduleddepublish" whenExpr="_eventdata"/>
        </transition>

      </state>

    </state>

    <state id="versioning" initial="no-versioning">

      <state id="no-versioning">
        <transition target="version" cond="supports.version and unpublished"/>
      </state>

      <state id="version">
        <onentry>
          <hippo:action action="version" enabledExpr="true"/>
          <hippo:action action="listVersions" enabledExpr="true"/>
          <hippo:action action="retrieveVersion" enabledExpr="true"/>
          <hippo:action action="restoreVersion" enabledExpr="true"/>
          <hippo:action action="versionRestoreTo" enabledExpr="true"/>
        </onentry>

        <transition event="version" target="reset">
          <hippo:version variant="unpublished"  />
        </transition>

        <transition event="listVersions">
          <hippo:listVersions variant="unpublished"  />
        </transition>

        <transition event="retrieveVersion">
          <hippo:retrieveVersion historic="_eventdata" variant="unpublished" />
        </transition>

        <transition event="versionRestoreTo" target="reset">
          <hippo:versionRestoreTo historic="_eventdata?.historic" variant="unpublished" target="_eventdata?.target"/>
        </transition>

        <transition event="restoreVersion" target="reset">
          <hippo:restoreVersion historic="_eventdata"  variant="unpublished" />
        </transition>

      </state>

    </state>

    <state id="terminate" initial="no-terminate">

      <state id="no-terminate">
        <transition target="terminateable" cond="supports.document and !live and !editing and !requestPending"/>
      </state>

      <state id="terminateable">
        <onentry>
          <hippo:action action="requestDelete" enabledExpr="true"/>
          <if cond="dm.isGranted(deleteSource, 'hippo:editor')">
            <hippo:action action="delete" enabledExpr="true"/>
            <hippo:action action="move" enabledExpr="true"/>
            <hippo:action action="rename" enabledExpr="true"/>
          </if>
        </onentry>

        <transition event="requestDelete" target="reset">
          <hippo:workflowRequest type="delete" contextVariantExpr="deleteSource"/>
        </transition>

        <transition event="delete" target="reset">
          <hippo:invokeDocumentWorkflow action="delete"/>
        </transition>

        <transition event="move" target="reset">
          <hippo:moveDocument destinationExpr="_eventdata?.destination" newNameExpr="_eventdata?.newName"/>
        </transition>

        <transition event="rename" target="reset">
          <hippo:renameDocument newNameExpr="_eventdata"/>
        </transition>

      </state>

    </state>

    <state id="copy" initial="no-copy">

      <state id="no-copy">
        <transition target="copyable" cond="supports.document and dm.isGranted(copySource,'hippo:editor')"/>
      </state>

      <state id="copyable">
        <onentry>
          <hippo:action action="copy" enabledExpr="true"/>
        </onentry>

        <transition event="copy" target="reset">
          <hippo:copyDocument destinationExpr="_eventdata?.destination" newNameExpr="_eventdata?.newName"/>
        </transition>

      </state>

    </state>

  </parallel>

  <final id="reset"/>
  <final id="terminated" />

</scxml>