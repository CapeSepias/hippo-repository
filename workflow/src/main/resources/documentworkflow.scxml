<?xml version="1.0" encoding="UTF-8" ?>
<!--
  Copyright 2013-2014 Hippo B.V. (http://www.onehippo.com)

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  -->
<scxml version="1.0"
       xmlns="http://www.w3.org/2005/07/scxml"
       xmlns:hippo="http://www.onehippo.org/cms7/repository/scxml"
       xmlns:cs="http://commons.apache.org/scxml">

  <script>
    def getScxmlId() { workflowContext.scxmlId }
    // draft variant property method
    def getDraft() { workflowData.documents['draft'] }
    // unpublished variant property method
    def getUnpublished() { workflowData.documents['unpublished'] }
    // published variant property method
    def getPublished() { workflowData.documents['published'] }
    // current user property method
    def getUser() { workflowContext.user }
    // current requests map property method
    def getRequests() { workflowData.requests }
    // returns the variant for copying and checking copy access privileges
    def getCopySource() { published ?: unpublished ?: null }
    // returns the variant for deleting and checking delete privileges
    def getDeleteSource() { unpublished ?: published ?: draft }
    // returns the current draft holder (editor) if defined (and draft exists)
    def getHolder() { draft?.holder }
    // true if draft exists and currently being edited
    def boolean isEditing() { !!holder }
    // true if draft exists and edited by current user
    def boolean isEditor() { holder == user }
    // true if draft exists and not currently editor or edited by current user
    def boolean isEditable() { !holder or editor }
    // true if published variant exists with availability 'live'
    def boolean isLive() { published?.isAvailable('live') }
    // true if unpublished variant exists with availability 'preview'
    def boolean isPreview() { unpublished?.isAvailable('preview') }
    // true if either unpublished or published variant exits with availability 'preview'
    def boolean isPreviewAvailable() { unpublished?.isAvailable('preview') or published?.isAvailable('preview') }
    // true if unpublished variant exists and no published variant exists with availability 'live'
    //                                        or they have a different lastModified
    def boolean isModified() { unpublished and (!live or unpublished.lastModified!=published.lastModified) }
    // true if there is an outstanding workflow request
    def boolean isRequestPending() { workflowData.requestPending }
    def getContainingFolder() { workflowData.handle.parent }
  </script>

  <parallel id="handle">

    <state id="status">
      <onentry>
        <hippo:feedback key="status" value="editable"/>
        <hippo:feedback key="isLive" value="live"/>
        <hippo:feedback key="previewAvailable" value="previewAvailable"/>
        <hippo:action action="checkModified" enabledExpr="draft and unpublished"/>
      </onentry>

      <transition event="checkModified">
        <hippo:isModified/>
        <hippo:result value="workflowContext.feedback['modified']"/>
      </transition>
    </state>

    <state id="edit">

      <state id="no-edit">
        <onentry>
          <hippo:action action="disposeEditableInstance" enabledExpr="false"/>
          <hippo:action action="obtainEditableInstance" enabledExpr="false"/>
          <hippo:action action="commitEditableInstance" enabledExpr="false"/>
        </onentry>
        <!-- transition to state "editing" when there is no pending request and the draft variant is being edited -->
        <transition target="editing"  cond="!requestPending and editing"/>
        <!-- else transition to state "editable" when there is no pending request and the draft variant doesn't exist
             yet or isn't being edited -->
        <transition target="editable" cond="!requestPending"/>
      </state>

      <state id="editing">
        <onentry>
          <if cond="editor">
            <hippo:action action="disposeEditableInstance" enabledExpr="true"/>
            <hippo:action action="obtainEditableInstance" enabledExpr="true"/>
            <hippo:action action="commitEditableInstance" enabledExpr="true"/>
          <else/>
            <!-- provide the current draft document holder as "inUseBy" feedback -->
            <hippo:feedback key="inUseBy" value="holder"/>
          </if>
          <!-- if not draft document holder AND granted hippo:admin -->
          <if cond="!editor and workflowContext.isGranted(draft,'hippo:admin')">
            <!-- then "unlock" action" is enabled -->
            <hippo:action action="unlock" enabledExpr="true"/>
          </if>
        </onentry>
      </state>

      <state id="editable">
        <onentry>
          <if cond="workflowContext.isGranted(draft,'hippo:admin')">
            <hippo:action action="unlock" enabledExpr="false"/>
          </if>
          <hippo:action action="obtainEditableInstance" enabledExpr="true"/>
        </onentry>
      </state>

      <transition event="disposeEditableInstance">
        <!-- remove holder from the draft document -->
        <hippo:setHolder holder="null"/>
        <hippo:result value="preview ? unpublished : published"/>
      </transition>

      <transition event="obtainEditableInstance">
        <if cond="!!unpublished">
          <!-- unpublished document exists: copy it to draft first -->
          <hippo:copyVariant sourceState="unpublished" targetState="draft"/>
        <elseif cond="!!published"/>
          <!-- else if published document exists: copy it to draft first -->
          <hippo:copyVariant sourceState="published" targetState="draft"/>
        </if>
        <!-- mark the draft document as modified, set the user as editor and remove possibly copied availabilities -->
        <hippo:configVariant variant="draft" applyModified="true" setHolder="true" availabilities=""/>
        <!-- store the newly created or updated draft document as result -->
        <hippo:result value="draft"/>
      </transition>

      <transition event="commitEditableInstance">
        <hippo:setHolder holder="null"/>
        <if cond="!!unpublished">
          <hippo:isModified/>
        </if>
        <if cond="!unpublished or workflowContext.feedback['modified']">
          <if cond="!unpublished and !!published">
            <if cond="live">
              <hippo:configVariant variant="published" availabilities="live"/>
            <else/>
              <hippo:configVariant variant="published" availabilities=""/>
            </if>
          </if>
          <hippo:copyVariant sourceState="draft" targetState="unpublished"/>
          <hippo:configVariant variant="unpublished" versionable="true" applyModified="true" availabilities="preview"/>
        </if>
        <hippo:result value="unpublished"/>
      </transition>

      <transition event="unlock">
        <!-- unlock the current draft document by setting the holder to the current (hippo:admin) user -->
        <hippo:setHolder holder="user"/>
      </transition>

    </state>

    <state id="request">

      <state id="no-request">
        <!-- transition to state "requested" when requests exists -->
        <transition target="requested" cond="!empty(requests)"/>
      </state>

      <state id="requested">
        <onentry>
          <foreach item="request" array="requests.values()">
            <if cond="request.workflowRequest">
              <if cond="workflowContext.isGranted(request, 'hippo:editor')">
                <if cond="request.workflowType!='rejected'">
                  <hippo:requestAction identifierExpr="request.identity" action="rejectRequest" enabledExpr="true"/>
                </if>
                <if cond="request.workflowType=='delete'">
                  <hippo:requestAction identifierExpr="request.identity" action="acceptRequest" enabledExpr="!live and !editing"/>
                <elseif cond="request.workflowType=='publish'">
                  <hippo:requestAction identifierExpr="request.identity" action="acceptRequest" enabledExpr="modified and !editing"/>
                </elseif>
                <elseif cond="request.workflowType=='depublish'"/>
                  <hippo:requestAction identifierExpr="request.identity" action="acceptRequest" enabledExpr="live and !editing"/>
                </if>
                <if cond="!request.owner or request.owner==user">
                  <hippo:requestAction identifierExpr="request.identity" action="cancelRequest" enabledExpr="true"/>
                </if>
              <elseif cond="request?.owner==user"/>
                <hippo:requestAction identifierExpr="request.identity" action="cancelRequest" enabledExpr="true"/>
              </if>
            <else/>
              <if cond="workflowContext.isGranted(request, 'hippo:editor')">
                <hippo:requestAction identifierExpr="request.identity" action="cancelRequest" enabledExpr="true"/>
              </if>
            </if>
          </foreach>
        </onentry>

        <transition event="acceptRequest">

          <!-- define temporary request variable for the event payload request parameter -->
          <cs:var name="request" expr="_event.data?.request"/>
          <!-- store the request workflow type as temporary variable -->
          <cs:var name="workflowType" expr="request.workflowType"/>
          <!-- store the request targetDate as temporary variable -->
          <cs:var name="targetDate" expr="request.scheduledDate"/>

          <!-- First delete the request itself.
               Note: after this the request object no longer can be accessed...
                     which is why we had to create the temporary variables workflowType and targetDate above first!
          -->
          <hippo:deleteRequest requestExpr="request"/>

          <if cond="!targetDate">
            <!-- the request didn't have a targetDate defined, simply trigger the "workflowType" value as event -->
            <send event="workflowType"/>
          <else/>
            <!-- the request did have a targetDate: trigger a 'scheduled' workflow action event -->
            <send event="workflowType" namelist="targetDate"/>
          </if>

        </transition>

        <transition event="rejectRequest">
          <hippo:rejectRequest requestExpr="_event.data?.request" reasonExpr="_event.data?.reason"/>
        </transition>

        <transition event="cancelRequest">
          <hippo:deleteRequest requestExpr="_event.data?.request"/>
        </transition>

      </state>

    </state>

    <state id="publish">

      <state id="no-publish">
        <onentry>
          <hippo:action action="requestPublication" enabledExpr="false"/>
          <if cond="workflowContext.isGranted(unpublished ?: published ?: draft, 'hippo:editor')">
              <hippo:action action="publish" enabledExpr="false"/>
          </if>
        </onentry>
        <transition target="publishable" cond="!editing and modified"/>
      </state>

      <state id="publishable">
        <onentry>
          <if cond="!requestPending or user=='system'">
            <hippo:action action="requestPublication" enabledExpr="true"/>
            <if cond="workflowContext.isGranted(unpublished, 'hippo:editor')">
              <hippo:action action="publish" enabledExpr="true"/>
            </if>
          </if>
        </onentry>

        <transition event="requestPublication" cond="!_event.data?.targetDate">
          <hippo:workflowRequest type="publish" contextVariantExpr="unpublished"/>
        </transition>

        <transition event="requestPublication" cond="!!_event.data?.targetDate">
          <hippo:workflowRequest type="scheduledpublish" contextVariantExpr="unpublished" targetDateExpr="_event.data?.targetDate"/>
        </transition>

        <transition event="publish" cond="!_event.data?.targetDate">
          <hippo:copyVariant sourceState="unpublished" targetState="published"/>
          <hippo:configVariant variant="published" applyPublished="true" availabilities="live"/>
          <hippo:version variant="unpublished"/>
        </transition>

        <transition event="publish" cond="!!_event.data?.targetDate">
          <hippo:scheduleWorkflow type="publish" targetDateExpr="_event.data?.targetDate"/>
        </transition>

      </state>

    </state>

    <state id="depublish">

      <state id="no-depublish">
        <onentry>
          <hippo:action action="requestDepublication" enabledExpr="false"/>
          <if cond="workflowContext.isGranted(published ?: unpublished ?: draft, 'hippo:editor')">
            <hippo:action action="depublish" enabledExpr="false"/>
          </if>
        </onentry>
        <transition target="depublishable" cond="!editing and live"/>
      </state>

      <state id="depublishable">
        <onentry>
          <if cond="!requestPending or user=='system'">
            <hippo:action action="requestDepublication" enabledExpr="true"/>
            <if cond="workflowContext.isGranted(published, 'hippo:editor')">
              <hippo:action action="depublish" enabledExpr="true"/>
            </if>
          </if>
        </onentry>

        <transition event="requestDepublication" cond="!_event.data?.targetDate">
          <hippo:workflowRequest type="depublish" contextVariantExpr="published"/>
        </transition>

        <transition event="requestDepublication" cond="!!_event.data?.targetDate">
          <hippo:workflowRequest type="scheduleddepublish" contextVariantExpr="published" targetDateExpr="_event.data?.targetDate"/>
        </transition>

        <transition event="depublish" cond="!_event.data?.targetDate">
          <if cond="!unpublished">
            <hippo:copyVariant sourceState="published" targetState="unpublished"/>
          </if>
          <hippo:configVariant variant="unpublished" versionable="true" availabilities="preview"/>
          <hippo:configVariant variant="published" availabilities=""/>
          <hippo:version variant="unpublished"/>
        </transition>

        <transition event="depublish" cond="!!_event.data?.targetDate">
          <hippo:scheduleWorkflow type="depublish" targetDateExpr="_event.data?.targetDate"/>
        </transition>

      </state>

    </state>

    <state id="versioning">

      <onentry>
        <!-- always enable the listVersions, even if no version is available (yet) -->
        <hippo:action action="listVersions" enabledExpr="true"/>
      </onentry>

      <!-- always support the listVersions operation -->
      <transition event="listVersions">
        <hippo:listVersions variant="unpublished" />
      </transition>

      <state id="no-versioning">
        <!-- a document only becomes versionable once an unpublished document variant exists -->
        <transition target="versionable" cond="!!unpublished"/>
      </state>

      <state id="versionable">
        <onentry>
          <hippo:action action="retrieveVersion" enabledExpr="true"/>
          <if cond="workflowContext.isGranted(unpublished, 'hippo:editor')">
            <hippo:action action="version" enabledExpr="true"/>
            <hippo:action action="restoreVersion" enabledExpr="true"/>
            <hippo:action action="versionRestoreTo" enabledExpr="true"/>
          </if>
        </onentry>

        <transition event="version">
          <hippo:version variant="unpublished"  />
        </transition>

        <transition event="retrieveVersion">
          <hippo:retrieveVersion historic="_event.data?.date" variant="unpublished" />
        </transition>

        <transition event="versionRestoreTo">
          <hippo:versionRestoreTo historic="_event.data?.date" variant="unpublished" target="_event.data?.target"/>
        </transition>

        <transition event="restoreVersion">
          <hippo:restoreVersion historic="_event.data?.date"  variant="unpublished" />
        </transition>

      </state>

    </state>

    <state id="terminate">

      <state id="no-terminate">
        <onentry>
          <hippo:action action="requestDelete" enabledExpr="false"/>
          <if cond="workflowContext.isGranted(deleteSource, 'hippo:editor') and workflowContext.isGranted(containingFolder, 'jcr:write')">
            <hippo:action action="delete" enabledExpr="false"/>
            <hippo:action action="move" enabledExpr="false"/>
            <hippo:action action="rename" enabledExpr="false"/>
          </if>
        </onentry>
        <transition target="terminateable" cond="!live and !editing"/>
      </state>

      <state id="terminateable">
        <onentry>
          <if cond="!requestPending">
            <hippo:action action="requestDelete" enabledExpr="true"/>
            <if cond="workflowContext.isGranted(deleteSource, 'hippo:editor') and workflowContext.isGranted(containingFolder, 'jcr:write')">
              <hippo:action action="delete" enabledExpr="true"/>
              <hippo:action action="move" enabledExpr="true"/>
              <hippo:action action="rename" enabledExpr="true"/>
            </if>
          </if>
        </onentry>

        <transition event="requestDelete">
          <hippo:workflowRequest type="delete" contextVariantExpr="deleteSource"/>
        </transition>

        <transition event="delete" target="terminated">
          <hippo:archiveDocument/>
        </transition>

        <transition event="move" target="terminated">
          <hippo:moveDocument destinationExpr="_event.data?.destination" newNameExpr="_event.data?.name"/>
        </transition>

        <transition event="rename" target="terminated">
          <hippo:renameDocument newNameExpr="_event.data?.name"/>
        </transition>

      </state>

    </state>

    <state id="copy">

      <state id="no-copy">
        <transition target="copyable" cond="workflowContext.isGranted(copySource,'hippo:editor')"/>
      </state>

      <state id="copyable">
        <onentry>
          <hippo:action action="copy" enabledExpr="true"/>
        </onentry>

        <transition event="copy">
          <hippo:copyDocument destinationExpr="_event.data?.destination" newNameExpr="_event.data?.name"/>
        </transition>

      </state>

    </state>

  </parallel>

  <final id="terminated" />

</scxml>